--- ast.c.orig	2015-05-21 23:19:07.293190378 +0200
+++ ast.c	2015-05-23 16:51:45.749460051 +0200
@@ -11,13 +11,13 @@
 
 #include <assert.h>
 
-static int validate_stmts(asdl_seq *);
-static int validate_exprs(asdl_seq *, expr_context_ty, int);
-static int validate_nonempty_seq(asdl_seq *, const char *, const char *);
-static int validate_stmt(stmt_ty);
-static int validate_expr(expr_ty, expr_context_ty);
+int validate_stmts(asdl_seq *);
+int validate_exprs(asdl_seq *, expr_context_ty, int);
+int validate_nonempty_seq(asdl_seq *, const char *, const char *);
+int validate_stmt(stmt_ty);
+int validate_expr(expr_ty, expr_context_ty);
 
-static int
+int
 validate_comprehension(asdl_seq *gens)
 {
     int i;
@@ -35,7 +35,7 @@
     return 1;
 }
 
-static int
+int
 validate_slice(slice_ty slice)
 {
     switch (slice->kind) {
@@ -60,7 +60,7 @@
     }
 }
 
-static int
+int
 validate_keywords(asdl_seq *keywords)
 {
     int i;
@@ -70,7 +70,7 @@
     return 1;
 }
 
-static int
+int
 validate_args(asdl_seq *args)
 {
     int i;
@@ -82,7 +82,7 @@
     return 1;
 }
 
-static const char *
+const char *
 expr_context_name(expr_context_ty ctx)
 {
     switch (ctx) {
@@ -104,7 +104,7 @@
     }
 }
 
-static int
+int
 validate_arguments(arguments_ty args)
 {
     if (!validate_args(args->args))
@@ -131,7 +131,7 @@
     return validate_exprs(args->defaults, Load, 0) && validate_exprs(args->kw_defaults, Load, 1);
 }
 
-static int
+int
 validate_expr(expr_ty exp, expr_context_ty ctx)
 {
     int check_ctx = 1;
@@ -283,7 +283,7 @@
     }
 }
 
-static int
+int
 validate_nonempty_seq(asdl_seq *seq, const char *what, const char *owner)
 {
     if (asdl_seq_LEN(seq))
@@ -292,20 +292,20 @@
     return 0;
 }
 
-static int
+int
 validate_assignlist(asdl_seq *targets, expr_context_ty ctx)
 {
     return validate_nonempty_seq(targets, "targets", ctx == Del ? "Delete" : "Assign") &&
         validate_exprs(targets, ctx, 0);
 }
 
-static int
+int
 validate_body(asdl_seq *body, const char *owner)
 {
     return validate_nonempty_seq(body, "body", owner) && validate_stmts(body);
 }
 
-static int
+int
 validate_stmt(stmt_ty stmt)
 {
     int i;
@@ -417,7 +417,7 @@
     }
 }
 
-static int
+int
 validate_stmts(asdl_seq *seq)
 {
     int i;
@@ -436,7 +436,7 @@
     return 1;
 }
 
-static int
+int
 validate_exprs(asdl_seq *exprs, expr_context_ty ctx, int null_ok)
 {
     int i;
@@ -496,28 +496,28 @@
     PyObject *c_normalize_args; /* Normalization argument tuple. */
 };
 
-static asdl_seq *seq_for_testlist(struct compiling *, const node *);
-static expr_ty ast_for_expr(struct compiling *, const node *);
-static stmt_ty ast_for_stmt(struct compiling *, const node *);
-static asdl_seq *ast_for_suite(struct compiling *, const node *);
-static asdl_seq *ast_for_exprlist(struct compiling *, const node *,
+asdl_seq *seq_for_testlist(struct compiling *, const node *);
+expr_ty ast_for_expr(struct compiling *, const node *);
+stmt_ty ast_for_stmt(struct compiling *, const node *);
+asdl_seq *ast_for_suite(struct compiling *, const node *);
+asdl_seq *ast_for_exprlist(struct compiling *, const node *,
                                   expr_context_ty);
-static expr_ty ast_for_testlist(struct compiling *, const node *);
-static stmt_ty ast_for_classdef(struct compiling *, const node *, asdl_seq *);
+expr_ty ast_for_testlist(struct compiling *, const node *);
+stmt_ty ast_for_classdef(struct compiling *, const node *, asdl_seq *);
 
 /* Note different signature for ast_for_call */
-static expr_ty ast_for_call(struct compiling *, const node *, expr_ty);
+expr_ty ast_for_call(struct compiling *, const node *, expr_ty);
 
-static PyObject *parsenumber(struct compiling *, const char *);
-static PyObject *parsestr(struct compiling *, const node *n, int *bytesmode);
-static PyObject *parsestrplus(struct compiling *, const node *n,
+PyObject *parsenumber(struct compiling *, const char *);
+PyObject *parsestr(struct compiling *, const node *n, int *bytesmode);
+PyObject *parsestrplus(struct compiling *, const node *n,
                               int *bytesmode);
 
 #define COMP_GENEXP   0
 #define COMP_LISTCOMP 1
 #define COMP_SETCOMP  2
 
-static int
+int
 init_normalization(struct compiling *c)
 {
     PyObject *m = PyImport_ImportModuleNoBlock("unicodedata");
@@ -536,7 +536,7 @@
     return 1;
 }
 
-static identifier
+identifier
 new_identifier(const char *n, struct compiling *c)
 {
     PyObject *id = PyUnicode_DecodeUTF8(n, strlen(n), NULL);
@@ -569,7 +569,7 @@
 
 #define NEW_IDENTIFIER(n) new_identifier(STR(n), c)
 
-static int
+int
 ast_error(struct compiling *c, const node *n, const char *errmsg)
 {
     PyObject *value, *errstr, *loc, *tmp;
@@ -611,7 +611,7 @@
    small_stmt elements is returned.
 */
 
-static int
+int
 num_stmts(const node *n)
 {
     int i, l;
@@ -805,7 +805,7 @@
 /* Return the AST repr. of the operator represented as syntax (|, ^, etc.)
 */
 
-static operator_ty
+operator_ty
 get_operator(const node *n)
 {
     switch (TYPE(n)) {
@@ -843,7 +843,7 @@
     NULL,
 };
 
-static int
+int
 forbidden_name(struct compiling *c, identifier name, const node *n, int full_checks)
 {
     assert(PyUnicode_Check(name));
@@ -870,7 +870,7 @@
    an appropriate syntax error and returns false.
 */
 
-static int
+int
 set_context(struct compiling *c, expr_ty e, expr_context_ty ctx, const node *n)
 {
     asdl_seq *s = NULL;
@@ -998,7 +998,7 @@
     return 1;
 }
 
-static operator_ty
+operator_ty
 ast_for_augassign(struct compiling *c, const node *n)
 {
     REQ(n, augassign);
@@ -1036,7 +1036,7 @@
     }
 }
 
-static cmpop_ty
+cmpop_ty
 ast_for_comp_op(struct compiling *c, const node *n)
 {
     /* comp_op: '<'|'>'|'=='|'>='|'<='|'!='|'in'|'not' 'in'|'is'
@@ -1088,7 +1088,7 @@
     return (cmpop_ty)0;
 }
 
-static asdl_seq *
+asdl_seq *
 seq_for_testlist(struct compiling *c, const node *n)
 {
     /* testlist: test (',' test)* [',']
@@ -1117,7 +1117,7 @@
     return seq;
 }
 
-static arg_ty
+arg_ty
 ast_for_arg(struct compiling *c, const node *n)
 {
     identifier name;
@@ -1154,7 +1154,7 @@
                      ^^^
    start pointing here
  */
-static int
+int
 handle_keywordonly_args(struct compiling *c, const node *n, int start,
                         asdl_seq *kwonlyargs, asdl_seq *kwdefaults)
 {
@@ -1222,7 +1222,7 @@
 
 /* Create AST for argument list. */
 
-static arguments_ty
+arguments_ty
 ast_for_arguments(struct compiling *c, const node *n)
 {
     /* This function handles both typedargslist (function definition)
@@ -1388,7 +1388,7 @@
     return arguments(posargs, vararg, kwonlyargs, kwdefaults, kwarg, posdefaults, c->c_arena);
 }
 
-static expr_ty
+expr_ty
 ast_for_dotted_name(struct compiling *c, const node *n)
 {
     expr_ty e;
@@ -1420,7 +1420,7 @@
     return e;
 }
 
-static expr_ty
+expr_ty
 ast_for_decorator(struct compiling *c, const node *n)
 {
     /* decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE */
@@ -1456,7 +1456,7 @@
     return d;
 }
 
-static asdl_seq*
+asdl_seq*
 ast_for_decorators(struct compiling *c, const node *n)
 {
     asdl_seq* decorator_seq;
@@ -1477,7 +1477,7 @@
     return decorator_seq;
 }
 
-static stmt_ty
+stmt_ty
 ast_for_funcdef(struct compiling *c, const node *n, asdl_seq *decorator_seq)
 {
     /* funcdef: 'def' NAME parameters ['->' test] ':' suite */
@@ -1511,7 +1511,7 @@
                        n->n_col_offset, c->c_arena);
 }
 
-static stmt_ty
+stmt_ty
 ast_for_decorated(struct compiling *c, const node *n)
 {
     /* decorated: decorators (classdef | funcdef) */
@@ -1541,7 +1541,7 @@
     return thing;
 }
 
-static expr_ty
+expr_ty
 ast_for_lambdef(struct compiling *c, const node *n)
 {
     /* lambdef: 'lambda' [varargslist] ':' test
@@ -1569,7 +1569,7 @@
     return Lambda(args, expression, LINENO(n), n->n_col_offset, c->c_arena);
 }
 
-static expr_ty
+expr_ty
 ast_for_ifexpr(struct compiling *c, const node *n)
 {
     /* test: or_test 'if' or_test 'else' test */
@@ -1595,7 +1595,7 @@
    Helper for ast_for_comprehension().
 */
 
-static int
+int
 count_comp_fors(struct compiling *c, const node *n)
 {
     int n_fors = 0;
@@ -1632,7 +1632,7 @@
    Helper for ast_for_comprehension().
 */
 
-static int
+int
 count_comp_ifs(struct compiling *c, const node *n)
 {
     int n_ifs = 0;
@@ -1650,7 +1650,7 @@
     }
 }
 
-static asdl_seq *
+asdl_seq *
 ast_for_comprehension(struct compiling *c, const node *n)
 {
     int i, n_fors;
@@ -1727,7 +1727,7 @@
     return comps;
 }
 
-static expr_ty
+expr_ty
 ast_for_itercomp(struct compiling *c, const node *n, int type)
 {
     /* testlist_comp: test ( comp_for | (',' test)* [','] )
@@ -1756,7 +1756,7 @@
         return NULL;
 }
 
-static expr_ty
+expr_ty
 ast_for_dictcomp(struct compiling *c, const node *n)
 {
     expr_ty key, value;
@@ -1779,21 +1779,21 @@
     return DictComp(key, value, comps, LINENO(n), n->n_col_offset, c->c_arena);
 }
 
-static expr_ty
+expr_ty
 ast_for_genexp(struct compiling *c, const node *n)
 {
     assert(TYPE(n) == (testlist_comp) || TYPE(n) == (argument));
     return ast_for_itercomp(c, n, COMP_GENEXP);
 }
 
-static expr_ty
+expr_ty
 ast_for_listcomp(struct compiling *c, const node *n)
 {
     assert(TYPE(n) == (testlist_comp));
     return ast_for_itercomp(c, n, COMP_LISTCOMP);
 }
 
-static expr_ty
+expr_ty
 ast_for_setcomp(struct compiling *c, const node *n)
 {
     assert(TYPE(n) == (dictorsetmaker));
@@ -1801,7 +1801,7 @@
 }
 
 
-static expr_ty
+expr_ty
 ast_for_atom(struct compiling *c, const node *n)
 {
     /* atom: '(' [yield_expr|testlist_comp] ')' | '[' [testlist_comp] ']'
@@ -1974,7 +1974,7 @@
     }
 }
 
-static slice_ty
+slice_ty
 ast_for_slice(struct compiling *c, const node *n)
 {
     node *ch;
@@ -2039,7 +2039,7 @@
     return Slice(lower, upper, step, c->c_arena);
 }
 
-static expr_ty
+expr_ty
 ast_for_binop(struct compiling *c, const node *n)
 {
     /* Must account for a sequence of expressions.
@@ -2091,7 +2091,7 @@
     return result;
 }
 
-static expr_ty
+expr_ty
 ast_for_trailer(struct compiling *c, const node *n, expr_ty left_expr)
 {
     /* trailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME
@@ -2174,7 +2174,7 @@
     }
 }
 
-static expr_ty
+expr_ty
 ast_for_factor(struct compiling *c, const node *n)
 {
     expr_ty expression;
@@ -2199,7 +2199,7 @@
     return NULL;
 }
 
-static expr_ty
+expr_ty
 ast_for_power(struct compiling *c, const node *n)
 {
     /* power: atom trailer* ('**' factor)*
@@ -2233,7 +2233,7 @@
     return e;
 }
 
-static expr_ty
+expr_ty
 ast_for_starred(struct compiling *c, const node *n)
 {
     expr_ty tmp;
@@ -2251,7 +2251,7 @@
 /* Do not name a variable 'expr'!  Will cause a compile error.
 */
 
-static expr_ty
+expr_ty
 ast_for_expr(struct compiling *c, const node *n)
 {
     /* handle the full range of simple expressions
@@ -2414,7 +2414,7 @@
     return NULL;
 }
 
-static expr_ty
+expr_ty
 ast_for_call(struct compiling *c, const node *n, expr_ty func)
 {
     /*
@@ -2455,6 +2455,9 @@
         return NULL;
     }
 
+    nargs+= nkeywords;
+    nkeywords= 0;
+
     args = _Py_asdl_seq_new(nargs + ngens, c->c_arena);
     if (!args)
         return NULL;
@@ -2466,13 +2469,15 @@
     for (i = 0; i < NCH(n); i++) {
         node *ch = CHILD(n, i);
         if (TYPE(ch) == argument) {
-            expr_ty e;
+            expr_ty e, e1;
             if (NCH(ch) == 1) {
+                /*
                 if (nkeywords) {
                     ast_error(c, CHILD(ch, 0),
                               "non-keyword arg after keyword arg");
                     return NULL;
                 }
+                */
                 if (vararg) {
                     ast_error(c, CHILD(ch, 0),
                               "only named arguments may follow *expression");
@@ -2493,26 +2498,28 @@
                 keyword_ty kw;
                 identifier key, tmp;
                 int k;
+                asdl_seq *kws;
+                expr_ty name;
 
                 /* CHILD(ch, 0) is test, but must be an identifier? */
-                e = ast_for_expr(c, CHILD(ch, 0));
-                if (!e)
+                e1 = ast_for_expr(c, CHILD(ch, 0));
+                if (!e1)
                     return NULL;
                 /* f(lambda x: x[0] = 3) ends up getting parsed with
                  * LHS test = lambda x: x[0], and RHS test = 3.
                  * SF bug 132313 points out that complaining about a keyword
                  * then is very confusing.
                  */
-                if (e->kind == Lambda_kind) {
+                if (e1->kind == Lambda_kind) {
                     ast_error(c, CHILD(ch, 0), "lambda cannot contain assignment");
                     return NULL;
-                } else if (e->kind != Name_kind) {
+                } else if (e1->kind != Name_kind) {
                     ast_error(c, CHILD(ch, 0), "keyword can't be an expression");
                     return NULL;
-                } else if (forbidden_name(c, e->v.Name.id, ch, 1)) {
+                } else if (forbidden_name(c, e1->v.Name.id, ch, 1)) {
                     return NULL;
                 }
-                key = e->v.Name.id;
+                key = e1->v.Name.id;
                 for (k = 0; k < nkeywords; k++) {
                     tmp = ((keyword_ty)asdl_seq_GET(keywords, k))->arg;
                     if (!PyUnicode_Compare(tmp, key)) {
@@ -2523,10 +2530,22 @@
                 e = ast_for_expr(c, CHILD(ch, 2));
                 if (!e)
                     return NULL;
+
+                /* build a call o(name=expr) */
+                identifier id = PyUnicode_FromString ("o");
+                name = Name(id, Load, e1->lineno, e1->col_offset, c->c_arena);
+
                 kw = keyword(key, e, c->c_arena);
                 if (!kw)
                     return NULL;
-                asdl_seq_SET(keywords, nkeywords++, kw);
+
+                kws = _Py_asdl_seq_new(1, c->c_arena);
+                if (!kws)
+                    return NULL;
+                asdl_seq_SET(kws, 0, kw);
+
+                /* ... and out it as an argument */
+                asdl_seq_SET(args, nargs++, Call(name, NULL, kws, NULL, NULL, e1->lineno, e1->col_offset, c->c_arena));
             }
         }
         else if (TYPE(ch) == STAR) {
@@ -2546,7 +2565,7 @@
     return Call(func, args, keywords, vararg, kwarg, func->lineno, func->col_offset, c->c_arena);
 }
 
-static expr_ty
+expr_ty
 ast_for_testlist(struct compiling *c, const node* n)
 {
     /* testlist_comp: test (comp_for | (',' test)* [',']) */
@@ -2570,7 +2589,7 @@
     }
 }
 
-static stmt_ty
+stmt_ty
 ast_for_expr_stmt(struct compiling *c, const node *n)
 {
     REQ(n, expr_stmt);
@@ -2667,7 +2686,7 @@
 }
 
 
-static asdl_seq *
+asdl_seq *
 ast_for_exprlist(struct compiling *c, const node *n, expr_context_ty context)
 {
     asdl_seq *seq;
@@ -2690,7 +2709,7 @@
     return seq;
 }
 
-static stmt_ty
+stmt_ty
 ast_for_del_stmt(struct compiling *c, const node *n)
 {
     asdl_seq *expr_list;
@@ -2704,7 +2723,7 @@
     return Delete(expr_list, LINENO(n), n->n_col_offset, c->c_arena);
 }
 
-static stmt_ty
+stmt_ty
 ast_for_flow_stmt(struct compiling *c, const node *n)
 {
     /*
@@ -2766,7 +2785,7 @@
     return NULL;
 }
 
-static alias_ty
+alias_ty
 alias_for_import_name(struct compiling *c, const node *n, int store)
 {
     /*
@@ -2885,7 +2904,7 @@
     return NULL;
 }
 
-static stmt_ty
+stmt_ty
 ast_for_import_stmt(struct compiling *c, const node *n)
 {
     /*
@@ -2998,7 +3017,7 @@
     return NULL;
 }
 
-static stmt_ty
+stmt_ty
 ast_for_global_stmt(struct compiling *c, const node *n)
 {
     /* global_stmt: 'global' NAME (',' NAME)* */
@@ -3019,7 +3038,7 @@
     return Global(s, LINENO(n), n->n_col_offset, c->c_arena);
 }
 
-static stmt_ty
+stmt_ty
 ast_for_nonlocal_stmt(struct compiling *c, const node *n)
 {
     /* nonlocal_stmt: 'nonlocal' NAME (',' NAME)* */
@@ -3040,7 +3059,7 @@
     return Nonlocal(s, LINENO(n), n->n_col_offset, c->c_arena);
 }
 
-static stmt_ty
+stmt_ty
 ast_for_assert_stmt(struct compiling *c, const node *n)
 {
     /* assert_stmt: 'assert' test [',' test] */
@@ -3069,7 +3088,7 @@
     return NULL;
 }
 
-static asdl_seq *
+asdl_seq *
 ast_for_suite(struct compiling *c, const node *n)
 {
     /* suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT */
@@ -3135,7 +3154,7 @@
     return seq;
 }
 
-static stmt_ty
+stmt_ty
 ast_for_if_stmt(struct compiling *c, const node *n)
 {
     /* if_stmt: 'if' test ':' suite ('elif' test ':' suite)*
@@ -3255,7 +3274,7 @@
     return NULL;
 }
 
-static stmt_ty
+stmt_ty
 ast_for_while_stmt(struct compiling *c, const node *n)
 {
     /* while_stmt: 'while' test ':' suite ['else' ':' suite] */
@@ -3296,7 +3315,7 @@
     return NULL;
 }
 
-static stmt_ty
+stmt_ty
 ast_for_for_stmt(struct compiling *c, const node *n)
 {
     asdl_seq *_target, *seq = NULL, *suite_seq;
@@ -3335,7 +3354,7 @@
                c->c_arena);
 }
 
-static excepthandler_ty
+excepthandler_ty
 ast_for_except_clause(struct compiling *c, const node *exc, node *body)
 {
     /* except_clause: 'except' [test ['as' test]] */
@@ -3389,7 +3408,7 @@
     return NULL;
 }
 
-static stmt_ty
+stmt_ty
 ast_for_try_stmt(struct compiling *c, const node *n)
 {
     const int nch = NCH(n);
@@ -3454,7 +3473,7 @@
 }
 
 /* with_item: test ['as' expr] */
-static withitem_ty
+withitem_ty
 ast_for_with_item(struct compiling *c, const node *n)
 {
     expr_ty context_expr, optional_vars = NULL;
@@ -3478,7 +3497,7 @@
 }
 
 /* with_stmt: 'with' with_item (',' with_item)* ':' suite */
-static stmt_ty
+stmt_ty
 ast_for_with_stmt(struct compiling *c, const node *n)
 {
     int i, n_items;
@@ -3504,7 +3523,7 @@
     return With(items, body, LINENO(n), n->n_col_offset, c->c_arena);
 }
 
-static stmt_ty
+stmt_ty
 ast_for_classdef(struct compiling *c, const node *n, asdl_seq *decorator_seq)
 {
     /* classdef: 'class' NAME ['(' arglist ')'] ':' suite */
@@ -3567,7 +3586,7 @@
                     decorator_seq, LINENO(n), n->n_col_offset, c->c_arena);
 }
 
-static stmt_ty
+stmt_ty
 ast_for_stmt(struct compiling *c, const node *n)
 {
     if (TYPE(n) == stmt) {
@@ -3639,7 +3658,7 @@
     }
 }
 
-static PyObject *
+PyObject *
 parsenumber(struct compiling *c, const char *s)
 {
     const char *end;
@@ -3682,7 +3701,7 @@
     }
 }
 
-static PyObject *
+PyObject *
 decode_utf8(struct compiling *c, const char **sPtr, const char *end)
 {
     const char *s, *t;
@@ -3693,7 +3712,7 @@
     return PyUnicode_DecodeUTF8(t, s - t, NULL);
 }
 
-static PyObject *
+PyObject *
 decode_unicode(struct compiling *c, const char *s, size_t len, int rawmode, const char *encoding)
 {
     PyObject *v, *u;
@@ -3762,7 +3781,7 @@
  * and r &/or b prefixes (if any), and embedded escape sequences (if any).
  * parsestr parses it, and returns the decoded Python string object.
  */
-static PyObject *
+PyObject *
 parsestr(struct compiling *c, const node *n, int *bytesmode)
 {
     size_t len;
@@ -3851,7 +3870,7 @@
  * compile-time literal catenation, calling parsestr() on each piece, and
  * pasting the intermediate results together.
  */
-static PyObject *
+PyObject *
 parsestrplus(struct compiling *c, const node *n, int *bytesmode)
 {
     PyObject *v;
